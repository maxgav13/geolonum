# Graficos

En este capitulo se muestra como crear diferentes tipos de graficos, tanto estaticos usando el paquete *ggplot2* [@ggplot22016; @R-ggplot2], como dinamicos usando los paquetes *highcharter* [@R-highcharter], *plotly* [@R-plotly], y *dygraphs* [@R-dygraphs].

En este capitulo se van a utilizar los siguientes paquetes:

```{r graficos-paquetes, warning=FALSE, message=FALSE}
library(babynames)
library(nycflights13)
library(gapminder)
library(dygraphs)
library(highcharter)
library(plotly)
library(RColorBrewer)
library(viridis)
library(rio)
library(cowplot)
library(patchwork)
library(tidymodels)
library(tidyverse)
```

Los tres primeros corresponden con conjuntos de datos. Asi mismo se vuelven a importar y manipular los datos con que se venia trabajando:

```{r graficos-datos}
data("airquality")
dat1 <- import("data/LungCapData2.csv", setclass = 'tibble')
titanic <- import("data/titanic.csv", setclass = 'tibble')

titanic = titanic %>% 
  mutate(Pclass = as_factor(Pclass),
         Survived = as_factor(Survived),
         Sex = as_factor(Sex))

airq = airquality %>% 
  mutate(Month = factor(Month,
                        levels = 5:9,
                        labels = c("Mayo", "Junio", "Julio", 
                                   "Agosto", "Setiembre")),
         Sensation = case_when(Temp < 60 ~ 'Cold',
                               Temp < 70 ~ 'Cool',
                               Temp < 85 ~ 'Warm',
                               T ~ 'Hot') %>% 
           as.factor())
```

## Estaticos

El paquete por exelencia, como se menciono al principio del capitulo, para crear graficos en **R** es *ggplot2*. Este se basa en la gramatica de graficos (grammar of graphics), de ahi el *gg* en el nombre. 

La estructura basica de cualquier graficos es:

```{r graficos-estructura, eval = FALSE}
ggplot(data = <DATA>) +
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>),
                  stat = <STAT>, position = <POSITION>) +
  <FACET_FUNCTION> +
  <SCALE_AESTHETIC_TYPE> +
  <THEME_FUNCTION>
```

donde las partes pricipales son `ggplot` y `geom_*`, el resto no son necesarias. Dentro de `geom_*` se mapean la variables de la tabla a los argumentos de la funcion (`x`, `y`, `col`, `fill`, `size`, `shape`, `alpha`). La idea basica es trabajar en capas para poder modificar el grafico con mayor detalle y facilidad.

### Histograma

Este se utiliza para datos numericos continuos.

Dentro de `geom_histogram` hay 3 opciones para definir la discretizacion:

* `bins` = Numero de clases
* `binwidth` = El ancho de las clases
* `breaks` = Un vector con los puntos donde separar los datos

El primer grafico (Figura \@ref(fig:graficos-hist1)) muestra el resultado de `geom_histogram` por defecto. Aqui se esta graficando la temperatura ('Temp') de la tabla 'airquality' en el eje x, es el eje que hay que usar en los histogramas.

```{r graficos-hist1, fig.cap='Histograma basico'}
p = ggplot(data = airquality, mapping = aes(x=Temp)) +
  geom_histogram()
p
```

La apariencia del grafico anterior se puede mejorar usando los argumentos `col` y `fill`, donde el primero corresponde con el color del borde de las barras, y el segundo con el relleno de las barras (Figura \@ref(fig:graficos-hist2)).

```{r graficos-hist2, fig.cap='Histograma modificando la cantidad de barras y apariencia'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,col="black",fill="blue")
```

El eje x, sobre el cual estamos graficando los datos, se puede modificar con mas detalle usando las funciones `scale_x_*`, donde en este caso usamos `scale_x_continuous()` por estar trabajando con datos continuos (Figura \@ref(fig:graficos-hist3)). El primer argumento de estas funciones es el nombre que se le quiere dar al eje, y en el caso siguiente, se modifican las etiquetas del eje con el argumento `labels`, donde se puede usar una de tantas funciones que se encuentran en el paquete *scales*.

```{r graficos-hist3, fig.cap='Histograma modificando la apariencia del eje x'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(binwidth = 2,col="black",fill="blue") + 
  scale_x_continuous('Temperatura', labels = label_number(suffix = ' ÂºC'))
```

Otra de las capas que se puede usar son las facetas o paneles, que permiten separar un tipo de grafico, en este caso un histograma, en diferentes graficos de acuerdo a otra variable, por lo general categorica (Figura \@ref(fig:graficos-hist4)). La funcion para esto es `facet_wrap(~ variable)`. Esta funcion es util para una variable, para dos o mas variables es mejor usar `facet_grid(filas ~ cols)` (Ver Figuras \@ref(fig:graficos-hist8) y \@ref(fig:graficos-hist9)).

```{r graficos-hist4, fig.cap='Histograma en paneles'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,col="black",fill="blue") +
  facet_wrap(~ Month)
```

Se venian rellenando las barras todas de un mismo color, por lo que el argumento `fill` se pone fuera del `aes()`. Si se quiere rellenar las barras de acuerdo al conteo o densidad es necesario insertar dentro del `aes()` de `geom_histogram` el `fill=after_stat(.)`, donde el punto (`.`) puede corresponder con el conteo (`count`) o la densidad (`density`). Asi como se modifica el eje x anteriormente con `scale_x_*`, se puede modificar el relleno con `scale_fill_*`. En este caso (Figura \@ref(fig:graficos-hist5)) se usa `scale_fill_distiller()` para usar una de las paletas disponibles en el paquete *RColorBrewer* [@R-RColorBrewer], donde se tiene que especificar el nombre de la paleta de colores a usar, en este caso `palette = 'YlOrRd'`.

```{r graficos-hist5, fig.cap='Histograma con relleno de acuerdo al conteo'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,aes(fill=after_stat(count)),col="black") +
  scale_fill_distiller(palette = 'YlOrRd')
```

Las paletas disponibles se observan en la Figura \@ref(fig:brewer-cols), donde el primer bloque de colores corresponde con las paletas secuenciales (`seq`), el segundo bloque con las paletas cualitativas (`qual`), y el tercer bloque con las paletas divergentes (`div`).

```{r brewer-cols, echo=FALSE, fig.cap='Paletas disponibles en RColorBrewer'}
RColorBrewer::display.brewer.all()
```

Asi como se puede modificar el relleno de las barras, se puede modificar que el eje y no corresponda con el conteo sino con la densidad (Figura \@ref(fig:graficos-hist6)), para esto es necesario insertar dentro del `aes()` de `geom_histogram` el `y=after_stat(density)`, y esto es necesario si se quiere agregar la curva de densidad de los datos (`geom_density`) para ver su distribucion.

```{r graficos-hist6, fig.cap='Histograma mostrando la densidad en el eje y en vez del conteo, con la curva de densidad superpuesta'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,aes(y=after_stat(density)),
                 col="black",fill="blue") +
  geom_density(col="red")
```

Combinando lo aprendido hasta ahora se pueden modificar el relleno junto con el eje y, asi como agregar la curva de densidad, para generar un grafico que brinda mas informacion (Figura \@ref(fig:graficos-hist7)).

```{r graficos-hist7, fig.cap='Histograma mostrando la densidad en el eje y en vez del conteo, con la curva de densidad superpuesta, y relleno de acuerdo al conteo'}
ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,
                 aes(y=after_stat(density),fill=after_stat(count)),
                 col="black") +
  geom_density(col="red")
```

Estos ultimos dos graficos agregan mas cosas que permiten crear graficos mas complejos e informativos sin mucho esfuerzo, incluyendo paneles de acuerdo a dos variables usando `facet_grid`. El primero (Figura \@ref(fig:graficos-hist8)) agrega el relleno de acuerdo a una variable categorica, asi como un paneleo por dos variables definiendo filas y columnas. El segundo (Figura \@ref(fig:graficos-hist9)) contruye sobre el primero pero modificando las etiquetas de los paneles usando el argumento `labeller`, donde se define `labeller(variable = vector con nombres)`, ademas se cambia el relleno con `scale_fill_viridis` y se modifican las etiquetas con un vector (`c('actual' = 'nuevo')`). El vector con nombres de `labeller` y el vector de etiquetas llevan la estructura `c('actual' = 'nuevo')`, donde 'actual' es el valor que tiene la variable y 'nuevo' es el nombre que se quiere aparezca en el grafico.

```{r graficos-hist8, fig.cap='Curva de densidad haciendo uso de varias variables categoricas'}
ggplot(titanic, aes(x = Age, fill = Survived)) +
  facet_grid(Sex ~ Pclass) +
  geom_density(alpha = 0.5)
```

```{r graficos-hist9, fig.cap='Version mejorada del grafico anterior'}
ggplot(titanic, aes(x = Age, fill = Survived)) +
  facet_grid(Sex ~ Pclass, 
             labeller = labeller(Sex = c('male'='Masculino',
                                         'female'='Femenino'),
                                 Pclass = c('1'='1era','2'='2nda','3'='3era'))) +
  geom_density(alpha = 0.5) +
  scale_fill_viridis_d('Sobrevivio', labels = c('1'='Si','0'='No'))
```

### Barras

Este se utiliza para datos categoricos.

Dentro de `geom_bar` el argumento *position* puede tener cualquiera de estos tres valores: 

* stack: Apila barras una encima de otra
* dodge: Pone barras de manera adyacente
* fill: Las barras tienen la misma altura, normalizadas a 1 (propociones)

`geom_bar` hace el conteo de clases, en caso de tener ya el conteo hecho se usa `geom_col`.

De manera general se puede pasar solo una variable para realizar el conteo, pero este tipo de graficos es mas util cuando se pueden agregar otras variables categoricas. 

En el primer ejemplo (Figura \@ref(fig:graficos-barra1)) se hace el conteo por genero, y se rellena por si fuman o no, lo que brinda una vision de la cantidad (o proporcion) de hombres y mujeres que fuman o no. En este ejemplo se utiliza `position = "fill"`, lo que hace que todas las barras tengan las misma altura y comprendan el rango de 0 a 1 en el eje y, lo que asemeja a una vision de proporciones. Adicionalmente, se modifica el eje y (`scale_y_continuous`) asignandole un nombre y cambiando las etiquetas a porcentaje (`labels = label_percent()`).

```{r graficos-barra1, fig.cap='Grafico de barras con el argumento de posicion `fill`, para mostrar proporciones entre categorias'}
ggplot(dat1, aes(Gender,fill=Smoke)) + 
  geom_bar(position = "fill") + 
  scale_y_continuous('Proporcion',labels = label_percent())
```

El siguiente grafico (Figura \@ref(fig:graficos-barra2)) es similar al primero, en que se grafican los mismos datos, pero de otra manera. Se usa `position = "dodge"`, lo que pone una barra a la par de la otra (esto para la categoria usada en el relleno); adicionalmente, se modifica el eje x (`scale_x_discrete`) asignandole un nombre y modificando los nombres de las etiquetas (`labels`); por ultimo, se modifica de forma manual el relleno (`scale_fill_manual`) asignandole un nombre, que es el que aparecer en la leyenda, las etiquetas (que deben tener el mismo orden de los niveles de la variable), y los valores (`values`) son los colores a usar para cada nivel.

```{r graficos-barra2, fig.cap='Grafico de barras con apariencia modificada y posisicon de las barras una a la par de la otra'}
ggplot(dat1, aes(Gender,fill=Smoke)) + 
  geom_bar(position = "dodge") + 
  scale_x_discrete('Genero', labels = c('Femenino','Masculino')) + 
  scale_fill_manual('Fumado', labels = c('Si','No'), 
                    values = c('darkred','green4'))
```

De igual manera se pueden generar paneles de acuerdo a una variable categorica (Figura \@ref(fig:graficos-barra3)).

```{r graficos-barra3, fig.cap='Grafico de barras en paneles'}
ggplot(titanic, aes(x = Sex, fill = Survived)) + 
  facet_wrap(~ Pclass) + 
  geom_bar()
```

Cuando se grafica una variable unicamente el orden de las barras va a estar en funcion del orden de los niveles (Figura \@ref(fig:graficos-barra4)), pero esta representacion puede que no sea la mas clara visualmente. Para corregir lo anterior se pueden reordenar los niveles de la variable (unicamente para el grafico) de acuerdo a la frecuencia (de mayor a menor), usando `fct_infreq` del paquete *forcats* (Figura \@ref(fig:graficos-barra5)).

```{r graficos-barra4, fig.cap='Grafico de barras basico con orden de barras de acuerdo al orden de los niveles'}
gss_cat %>% 
  ggplot(aes(marital)) + 
  geom_bar()
```

```{r graficos-barra5, fig.cap='Grafico de barras ordenado de acuerdo a la frecuencia de los niveles'}
gss_cat %>% 
  ggplot(aes(fct_infreq(marital))) + 
  geom_bar()
```

Los ejemplos anteriores usaban `geom_bar`, pero en el caso de que ya se tenga el conteo se puede usar `geom_col`. En este caso hay que especificar la variable a graficar en `x` y el conteo en `y`, el resto de modificaciones se pueden aplicar de igual manera a como se venia mostrando. En este ejemplo (Figura \@ref(fig:graficos-barra6)) debido a que los niveles corresponden con nombres largos y hay muchos, se usa el cambiar los ejes por medio de `coord_flip`, lo que va a poner en 'y' lo que estaba en 'x' y viceversa.

```{r graficos-barra6, fig.cap='Grafico de barras precontado y cambiando ejes para mayor claridad'}
mpg %>% 
  count(manufacturer, year) %>% 
  mutate(year = as.factor(year)) %>% 
  ggplot(aes(manufacturer,n,fill=year)) + 
  geom_col(position = 'dodge') + 
  coord_flip() + 
  scale_fill_brewer(palette = 'Dark2')
```

### Boxplot

Este tipo se usa para datos numericos continuos que normalmente se separan por una variable categorica. Los datos continuos se grafican en el eje y, por lo que hay que especificar esto explicitamente en el `aes()` (Figura \@ref(fig:graficos-box1)), y si se quiere separar por una variable categorica, esta se asigna al eje x (Figura \@ref(fig:graficos-box2)).

```{r graficos-box1, fig.cap='Grafico boxplot basico'}
ggplot(airq,aes(y=Temp)) +
  geom_boxplot()
```

```{r graficos-box2, fig.cap='Grafico boxplot separado por variable categorica'}
ggplot(airq,aes(x = Month,y = Temp)) +
  geom_boxplot()
```

En el tercer ejemplo (Figura \@ref(fig:graficos-box3)) se agregan un par de funciones que no se habian visto: `labs` y `theme_bw`. `labs` permite modificar los nombres de los ejes y esteticas (`col`, `fill`, etc.) sin tener que usar las funciones `scale_*_*`. `theme_bw` es uno de los tantos temas que vienen definidos y cambia la apariencia a un grafico en blanco y negro, removiendo el fondo gris que en muchos casos no es lo mejor.

```{r graficos-box3, fig.cap='Grafico boxplot con apariencia modificada'}
ggplot(airq,aes(x = Month,y = Temp)) +
  geom_boxplot(fill="white",col="red") +
  labs(x="Mes",y="Temperatura") +
  theme_bw()
```

### Dispersion

Estos aplican para datos numericos continuos en ambos ejes. Un grafico basico se muestra en el primer ejemplo (Figura \@ref(fig:graficos-disper1)).

```{r graficos-disper1, fig.cap='Grafico de dispersion basico'}
ggplot(airquality, aes(Ozone,Temp)) + 
  geom_point()
```

Para el caso de puntos se puede cambiar el tipo de icono con el argumento `shape`, este puede definirse de manera global para todos los puntos o de acuerdo a una variable categorica (Figura \@ref(fig:graficos-disper2)).

```{r graficos-disper2, fig.cap='Grafico de dispersion con la forma de los puntos de acuerdo a una variable categorica'}
ggplot(airq, aes(Ozone,Temp,shape=Month)) + 
  geom_point()
```

Una tarea comun en graficos de dispersion es agregar lineas de tendencia. Para agregar lineas de tendencia en *ggplot2* se usa la funcion `geom_smooth`. Por defecto ajusta una curva loess, pero para cambiarlo se usa el argumento `method = 'lm'` (Figura \@ref(fig:graficos-disper3)), y para especificar una ecuacion diferente a la regresion simple (`y ~ x`) se usa `formula`, donde `y` y `x` son genericos (Figura \@ref(fig:graficos-disper4)), **NO** hay que poner el nombre de las variables que se esta graficando.

```{r graficos-disper3, fig.cap='Grafico de dispersion con linea de tendencia lineal'}
ggplot(airquality, aes(Wind,Temp)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

```{r graficos-disper4, fig.cap='Grafico de dispersion con linea de tendencia polinomial'}
ggplot(airquality, aes(Ozone,Temp)) + 
  geom_point() + 
  geom_smooth(method = "lm", formula = y~poly(x,2))
```

En este caso (Figura \@ref(fig:graficos-disper5)) cuando se aplica el paneleo (`facet_wrap`) se obtiene una grafico de dispersion con su respectiva linea de tendencia para cada uno de los niveles de la variable categorica.

```{r graficos-disper5, fig.cap='Grafico de dispersion en paneles con linea de tendencia para cada panel'}
ggplot(airquality, aes(Wind,Temp)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  facet_wrap(~ Month)
```

### Lineas

Estos graficos son una version del grafico de dispersion, donde el eje x corresponde con una variable continua que tiene cierta secuencia o patron, por lo general tiempo o espacio.

El primer grafico (Figura \@ref(fig:graficos-linea1)) muestra como ha cambiado el uso del nombre 'Max' a lo largo del tiempo. Primero se filtran los datos para el nombre de interes, y se seleccionan las variables a usar en el grafico. Como el eje y corresponde con proporcion, se modifica para que muestre el porcentaje.

```{r graficos-linea1, fig.cap='Grafico de linea basico'}
babynames %>% 
  filter(name == "Max") %>% 
  select(year, prop, sex) %>% 
  ggplot(mapping = aes(x = year, y = prop)) + 
  geom_line(mapping = aes(color = sex)) + 
  scale_y_continuous(labels = label_percent())
```

En el segundo grafico de lineas (Figura \@ref(fig:graficos-linea2)) se grafica el numero de tormentas por anho, de nuevo, realizando una manipulacion de los datos para obtener la informacion que se desea desplegar. El ultimo grafico (Figura \@ref(fig:graficos-linea3)) simplemente hace la separacion de diferentes lineas de acuerdo a una variable categorica.

```{r graficos-linea2, fig.cap='Grafico de linea basico con otros datos'}
storms %>%
  group_by(year) %>% 
  summarize(n_storm = n_distinct(name)) %>% 
  ggplot() +
  geom_line(mapping = aes(x = year, y = n_storm))
```

```{r graficos-linea3, fig.cap='Grafico de linea basico, con diferentes lineas de acuerdo a una variable categorica'}
storms %>%
  group_by(year,status) %>% 
  summarize(n_storm = n_distinct(name)) %>% 
  ggplot() +
  geom_line(mapping = aes(x = year, y = n_storm, col = status))
```

### Graficos estadisticos

Estos sirven para resumir los datos. Los ejemplos que aqui se muestran corresponden con el despliegue de intervalos de confianza de una variable numerica para diferentes niveles de una variable categorica.

```{r graficos-stat1, fig.cap='Grafico estadistico mostrando intervalo de confianza como barras de error'}
ggplot(airquality, aes(Month, Temp)) +
  stat_summary(fun.y = mean,
               geom = "point",
               color = "black") +
  stat_summary(fun.data = mean_cl_normal,
               geom = "errorbar",
               width = 0.2) +
  theme_bw()
```

```{r graficos-stat2, fig.cap='Grafico estadistico mostrando intervalo de confianza como punto y rango'}
ggplot(airquality, aes(Month, Temp)) +
  stat_summary(fun.data = mean_cl_normal,
               geom = "pointrange",
               color = "red",
               size=1) +
  theme_bw()
```

### Transformacion de ejes

En algunas ocasiones, dependiendo de la escala y rango que tenga los datos, una transformacion de uno o ambos ejes sea necesaria, siendo los mas tipico para datos numericos continuos. El ejemplo mas tipico es la tranformacion logaritmica (natural o base 10), para los casos donde los datos comprenden varios ordenes de magnitud.

En *ggplot2* esto puede hacerse de dos maneras:

* `scale_<eje>_<tipo>(trans = '#')`,
* `coord_trans(<eje> = '#')`

donde `#` corresponde con la tranformacion a realizar, y puede tomar los siguientes valores: "asn", "atanh", "boxcox", "date", "exp", "hms", "identity", **"log"**, **"log10"**, "log1p", "log2", "logit", "modulus", "probability", "probit", "pseudo_log", "reciprocal", **"reverse"**, "sqrt", y "time". Siendo las mas comunes las resaltadas en negrita, donde "log" se refiere al logaritmo natural, "log10" al logaritmo base 10, y "reverse" para invertir el eje.

La diferencia de usar `scale_*` o `coord_trans` radica en cuando se aplica la tranformacion. Con `scale_*` la transformacion es aplicada a los datos antes de ser graficados, por lo que se grafica son los datos transformados (Figura \@ref(fig:graficos-trans1, B)); con `coord_trans` la transformacion se aplica despues de ser graficados, o sea se aplica sobre el eje, modificando la apariencia y no los datos en si (Figura \@ref(fig:graficos-trans1, C)). 

La Figura \@ref(fig:graficos-trans1), es una grilla de graficos, la cual fue realizada por medio de *cowplot* [@R-cowplot]. Otro paquete para generar grillas de graficos es *patchwork* [@R-patchwork], y este ofrece mas flexibilidad con la manipulacion y posicionamiento de los graficos (Figura \@ref(fig:graficos-trans2)). 
En ambos casos, se ve claramente en el subgrafico **A** que el eje x tiene varios ordenes de magnitud. En el subgrafico **B** se aplico `scale_x_continuous(trans = 'log10')`, lo cual aplica una transformacion logaritmica a los datos antes de plotearlos y por eso los diferentes valores. En el subgrafico **C** se aplico `coord_trans(x = 'log10')`, lo cual simplemente modifica la apriencia del eje, donde se observa esa escala logaritmica, manteniendo los valores originales; adicionalmente se cambian los valores del eje (`scale_x_continuous(breaks = c(10,100,1000,10000))`) para que no se vean tan apilados.

```{r graficos-trans1, fig.cap='Ejemplo de transformacion de ejes, en este caso solo el eje x, usando *cowplot*. **A** es el grafico sin datos tranformados; **B** es el grafico usando `scale_*`; **C** es el grafico usando `coord_trans`'}
cow1 = ggplot(msleep) + 
  geom_point(aes(bodywt,sleep_total))

cow2 = ggplot(msleep) + 
  geom_point(aes(bodywt,sleep_total)) + 
  scale_x_continuous(trans = 'log10')

cow3 = ggplot(msleep) + 
  geom_point(aes(bodywt,sleep_total)) + 
  coord_trans(x = 'log10') +
  scale_x_continuous(breaks = c(10,100,1000,10000))

plot_grid(cow1, cow2, cow3, ncol = 1, labels = 'AUTO')
```

```{r graficos-trans2, fig.cap='Ejemplo de transformacion de ejes, en este caso solo el eje x, usando *patchwork*. **A** es el grafico sin datos tranformados; **B** es el grafico usando `scale_*`; **C** es el grafico usando `coord_trans`'}

cow1 / (cow2 | cow3) + 
  plot_annotation(tag_levels = 'A') & 
  theme_bw()
```

### Limites de ejes (Zoom)

Otra accion que tal vez se quiera realizar puede ser delimitar los valores minimos y maximos de los ejes, ya sea para tener control sobre estos, o para realizar una especie de acercamiento (zoom) en una region del grafico.

La manera apropiada de realizar esto es por medio de `coord_cartesian(*lim)`, donde `*lim` se refiere al eje x o y. la otra forma que tal vez aparezca por ahi, pero no da los resultados deseados es usando `scale_<eje>_<tipo>(limits)`. En ambos casos se brinda un vector de minimo y maximo.

La Figura \@ref(fig:graficos-zoom) muestra el grafico inicial, y como afectan las diferentes funciones. De manera similar a la transformacion, `scale_*` aplica los limites antes de graficar, por lo que los datos que caen fuera de esos limites son descartados y no ploteados (de ahi la advertencia). En cambio, `coord_cartesian` aplica los limites despues de graficados los datos, por lo que simplemente es un cambio en la representacion del eje y no en los datos.

```{r graficos-zoom, fig.cap='Ejemplo de modificar los limites del eje y en este caso. **A** es el grafico original **B** es el grafico usando `scale_*`; **C** es el grafico usando `coord_cartesian`'}
z1 = gss_cat %>% 
  ggplot(aes(y=marital)) + 
  geom_bar()

z2 = gss_cat %>% 
  ggplot(aes(y=marital)) + 
  geom_bar() + 
  scale_x_continuous(limits = c(0,5000))

z3 = gss_cat %>% 
  ggplot(aes(y=marital)) + 
  geom_bar() + 
  coord_cartesian(xlim = c(0,5000))

z1 / (z2 | z3) + 
  plot_annotation(tag_levels = 'A') & 
  theme_bw()
```


### Salvando graficos

Se muestran funciones para salvar graficos, donde las extensiones mas usadas son `.png`, `.tiff`, y `.pdf`. Por defecto `ggsave` salva el ultimo grafico creado, a menos que se haya guardado el grafico en un objeto y se le pase dicho objeto al argumento `plot`. El resto de argumentos son claros en lo que representan. Para el caso de un `.pdf` hay que remover el argumento `type`.

```{r eval=F}
ggsave(filename = "figs/Testgg.png",
       plot = p, dpi = 300,
       width = 7, height = 4, units = "in",
       type = "cairo")

ggsave(filename = "figs/Testgg.pdf",
       plot = p, dpi = 300,
       width = 7, height = 4, units = "in")
```

## Interactivos

Una vez sabiendo utilizar *ggplot2* la forma mas sencilla de hacer un grafico interactivo es mediante `plotly::ggplotly()`. El paquete *plotly* [@R-plotly] se usa para graficos interactivos y tiene una sintaxis un poco diferente a *ggplot2*, por lo que hay ciertos graficos que no van a ser convertidos apropiadamente, pero la mayoria de graficos debieran funcionar.

Otros paquetes para graficos interactivos son:

* *highcarter*: Sintaxis similar a ggplot, con ciertas limitantes,
* *rbokeh*: Graficos interactivos generales,
* *dygraphs*: Series temporales,
* *mapview* y *leaflet*: Mapas

En las siguientes secciones se va a recrear alguno de los graficos anteriores para hacerlo interactivo con `ggplotly`, y se va a crear uno similar con *highcharter*. El ejercicio de entender como funciona *highcharter* queda a acargo del lector, en general los ejemplos y funciones son claras.

Una caracteristica de estos graficos interactivo, cuando tienen leyenda, es que al hacer click sobre una de la entradas de la leyenda, esta serie de datos es escondida del grafico, dejando visible unicamente lo otro. En el caso de *highcharter* los ejes se ajustan automaticamente, este no es el caso para *plotly*.

### Histograma

La version interctiva de la Figura \@ref(fig:graficos-hist7) se muestra en la Figura \@ref(fig:graficos-inter1), la version usando *highcharter* se muestra en la Figura \@ref(fig:graficos-inter2).

```{r graficos-inter1, fig.cap='Grafico interactivo de un histograma con plotly'}
(ggplot(airquality,aes(x=Temp)) +
  geom_histogram(bins = 20,
                 aes(y=after_stat(density),fill=after_stat(count)),
                 col="black") +
  geom_density(col="red")) %>% 
  plotly::ggplotly()
```

```{r graficos-inter2, fig.cap='Grafico interactivo de un histograma con highcharter'}
with(airq, hchist(Temp,color='red',name='Temp')) %>% 
  hc_xAxis(title = list(text = 'Temperatura')) %>% 
  hc_exporting(enabled=T)
```

### Barras

La version interctiva de la Figura \@ref(fig:graficos-barra6) se muestra en la Figura \@ref(fig:graficos-inter3), la version usando *highcharter* se muestra en la Figura \@ref(fig:graficos-inter4).

```{r graficos-inter3, fig.cap='Grafico interactivo de barras con plotly'}
(mpg %>% 
  count(manufacturer, year) %>% 
  mutate(year = as.factor(year)) %>% 
  ggplot(aes(manufacturer,n,fill=year)) + 
  geom_col(position = 'dodge') + 
  coord_flip() + 
  scale_fill_brewer(palette = 'Dark2')) %>% 
  plotly::ggplotly()
```

```{r graficos-inter4, fig.cap='Grafico interactivo de barras con highcharter'}
mpg %>% 
  count(manufacturer, year) %>% 
  hchart('bar', hcaes(x = manufacturer, y = n, group = year)) %>% 
  hc_xAxis(title = list(text = 'Constructor')) %>%
  hc_yAxis(title = list(text = 'Cantidad')) %>%
  hc_exporting(enabled=T)
```

### Boxplot

La version interctiva de la Figura \@ref(fig:graficos-box2) se muestra en la Figura \@ref(fig:graficos-inter5), la version usando *highcharter* se muestra en la Figura \@ref(fig:graficos-inter6).

```{r graficos-inter5, fig.cap='Grafico interactivo boxplot con plotly'}
(ggplot(airq,aes(x = Month,y = Temp)) +
  geom_boxplot()) %>% 
  plotly::ggplotly()
```

```{r graficos-inter6, fig.cap='Grafico interactivo boxplot con highcharter'}
with(airq, hcboxplot(x = Temp, var = Month)) %>% 
  hc_yAxis(title = list(text = 'Temperatura')) %>%
  hc_xAxis(title = list(text = 'Mes')) %>%
  hc_exporting(enabled=T)
```

### Dispersion

La version interctiva de la Figura \@ref(fig:graficos-disper3) se muestra en la Figura \@ref(fig:graficos-inter7), la version usando *highcharter* se muestra en la Figura \@ref(fig:graficos-inter8), con el agregado de que muestra la ecuacion de cada linea de tendencia.

```{r graficos-inter7, fig.cap='Grafico interactivo de dispersion con plotly'}
(ggplot(airquality, aes(Wind,Temp)) + 
  geom_point() + 
  geom_smooth(method = "lm")) %>% 
  plotly::ggplotly()
```

```{r graficos-inter8, fig.cap='Grafico interactivo de dispersion con highcharter'}
hchart(airq, 'scatter', hcaes(Wind, Temp, group=Month), regression = T) %>% 
  hc_xAxis(title = list(text = 'Viento')) %>%
  hc_yAxis(title = list(text = 'Temperatura')) %>%
  hc_colors(viridis(n_distinct(airq$Month))) %>% 
  hc_add_dependency('plugins/highcharts-regression.js') %>% 
  hc_exporting(enabled=T)
```

### Lineas

La version interctiva de la Figura \@ref(fig:graficos-linea3) se muestra en la Figura \@ref(fig:graficos-inter9), la version usando *highcharter* se muestra en la Figura \@ref(fig:graficos-inter10), y la version usando *dygraphs* se muestra en la Figura \@ref(fig:graficos-inter11). En este ultimo caso es necesario que los datos esten en formato ancho, donde la primer columna corresponde con el eje x, y el resto de columnas corresponden con las series temporales/espaciales a graficar por separado.

```{r graficos-inter9, fig.cap='Grafico interactivo de lineas con plotly'}
(storms %>%
  group_by(year,status) %>% 
  summarize(n_storm = n_distinct(name)) %>% 
  ggplot() +
  geom_line(mapping = aes(x = year, y = n_storm, col = status))) %>% 
  plotly::ggplotly()
```

```{r graficos-inter10, fig.cap='Grafico interactivo de lineas con highcharter'}
storms %>%
  group_by(year,status) %>% 
  summarize(n_storm = n_distinct(name)) %>% 
  hchart('line', hcaes(year, n_storm, group = status)) %>% 
  hc_xAxis(title = list(text = 'Anho')) %>%
  hc_yAxis(title = list(text = 'Cantidad')) %>%
  hc_exporting(enabled=T) %>% 
  hc_tooltip(shared=T,crosshairs=T,
             backgroundColor='rgba(247,247,247,0.5)',shadow=F) %>% 
  hc_chart(zoomType='x')%>%
  hc_add_theme(hc_theme_google()) %>% 
  hc_plotOptions(line = list(marker = list(
                               enabled = F,
                               radius = 2
                               )
  ))
```

```{r graficos-inter11, fig.cap='Grafico interactivo de lineas con dygraphs'}
storms %>%
  group_by(year,status) %>% 
  summarize(n_storm = n_distinct(name)) %>% 
  pivot_wider(names_from = status,values_from = n_storm) %>% 
  dygraph() %>% 
  dyAxis('x', label = 'Anho') %>% 
  dyAxis('y', label = 'Cantidad') %>% 
  dyRangeSelector()
```

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```
